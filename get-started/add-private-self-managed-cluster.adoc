---
sidebar: sidebar 
permalink: get-started/add-private-self-managed-cluster.html 
keywords: discover cluster, add cluster, add kubernetes cluster, discover kubernetes cluster, add cluster 
summary: 環境のセットアップが完了したら、 Kubernetes クラスタを作成し、 Astra Control Service に追加することができます。 
---
= Astra Control Serviceに自己管理型プライベートクラスタを追加
:hardbreaks:
:allow-uri-read: 
:icons: font
:imagesdir: ../media/get-started/


[role="lead"]
環境のセットアップが完了したら、 Kubernetes クラスタを作成し、 Astra Control Service に追加することができます。

自己管理型クラスタは、ユーザが直接プロビジョニングおよび管理するクラスタです。Astra Control Serviceは、パブリッククラウド環境で実行される自己管理型クラスタをサポートします。をアップロードすることで、Astra Control Serviceに自己管理型クラスタを追加できます `kubeconfig.yaml` ファイル。クラスタがここで説明する要件を満たしていることを確認する必要があります。



== サポートされているKubernetesディストリビューション

Astra Control Serviceを使用して、次のタイプの自己管理型プライベートクラスタを管理できます。

|===
| Kubernetesディストリビューション | サポートされるバージョン 


| Azure Stack HCIで実行されるAzure Kubernetes Service | Azure Stack HCI 21H2および22H2（AKS 1.23および1.24を使用 


| Google Anthos | 1.12から1.14まで 


| Kubernetes（アップストリーム） | 1.24~1.26（Kubernetes 1.25以降にはAstra Trident 22.10以降が必要） 


| Rancher Kubernetes Engine （ RKE ） | RKE 1.3とRancher 2.6
RKE 1.4とRancher 2.7
RKE 2（v1.23.x）とRancher 2.6
RKE 2（v1.24.x）とRancher 2.7 


| Red Hat OpenShift Container Platform | 4.10から4.12まで 


| VMware Tanzu Kubernetesグリッド | 1.6 


| VMware Tanzu Kubernetes Grid統合エディション | 1.14および1.15 
|===
ここで説明する手順は、すでにプライベートクラスタを作成し、リモートからアクセスするためのセキュアな方法を準備していることを前提としています。

Astra Control Serviceにプライベートクラスタを追加するには、次のタスクを実行する必要があります。

* <<Astra Connectorオペレータを設置します>>
* <<永続的ストレージをセットアップする>>
* <<Astra Control Serviceに自己管理型プライベートクラスタを追加>>




== Astra Connectorオペレータを設置します

Astra Connectorオペレータはプライベートクラスタにインストールする必要があります。要塞ホストを使用している場合は、要塞ホストのコマンドラインからこれらのコマンドを問題 で実行します。

.手順
. Astra ConnectorオペレータGitHubリポジトリのクローンを作成します。
+
[source, console]
----
git clone https://github.com/NetApp/astra-connector-operator.git
----
. 展開された演算子パッケージの最上位レベルにディレクトリを変更して'straconnector _operator.yaml'ファイルを'ls'コマンドで表示できるようにします
. を適用します `astraconnector_operator.yaml` ファイル。このコマンドを実行すると、Astra Connectorオペレータ用の正しいネームスペースが作成され、その設定がネームスペースに適用されます。
+
[source, console]
----
kubectl apply -f astraconnector_operator.yaml
----
. プライベートクラスタコンポーネントのネームスペースを作成します。
+
[source, console]
----
kubectl create ns astra-connector
----
. の手順に従って、Astra Control APIトークンを生成します https://docs.netapp.com/us-en/astra-automation/get-started/get_api_token.html["Astra Automationのドキュメント"^]。
. Astra Connectorオペレータリポジトリのconfig/samplesディレクトリにある構成ファイルの例を変更して、次のキーに対応する環境固有の値を追加します。
+
** `spec.natssync-client.cloud-bridge-url`
** `spec.astra.token`
** `spec.astra.clusterName`
+

NOTE: `spec.astra.clusterName` プライベートAKSクラスタをインポートし、Astra Control Serviceにkubeconfigファイルを提供しない場合にのみ必要です。そうでない場合は、この行を削除してください。

** `spec.astra.accountId`
+
例：

+
[listing]
----
apiVersion: netapp.astraconnector.com/v1
kind: AstraConnector
metadata:
  name: astra-connector
spec:
  natssync-client:
    image: natssync-client:2.0
    cloud-bridge-url: https://<your.astra.control.service.url>
  nats:
    image: nats:2.6.1-alpine3.14
  httpproxy-client:
    image: httpproxylet:2.0
  echo-client:
    image: echo-proxylet:2.0
  imageRegistry:
    name: theotw
  astra:
    token: <Astra Control API token>
    clusterName: <your-private-AKS-cluster-name>
    accountId: <Astra Control account id>
    acceptEULA: yes
----


. Astra Connector Custom Resource Definition（CRD）を適用します。
+
[source, console]
----
kubectl apply -f config/samples/astraconnector_v1.yaml -n astra-connector
----
. Astra Connectorのステータスを確認します。
+
[source, console]
----
kubectl get astraconnector astra-connector -n astra-connector
----
+
次のような出力が表示されます。

+
[source, console]
----
NAME              REGISTERED   ASTRACONNECTORID
astra-connector   true         22b839aa-8b85-445a-85dd-0b1f53b5ea19
----




== 永続的ストレージをセットアップする

クラスタに永続的ストレージを設定してください。永続的ストレージの設定の詳細については、『Get Started』ドキュメントを参照してください。

ifdef::azure[]

* link:set-up-microsoft-azure-with-anf.html["Azure NetApp Files を使用して Microsoft Azure をセットアップする"^]
* link:set-up-microsoft-azure-with-amd.html["Azure で管理されているディスクを使用して Microsoft Azure をセットアップする"^]


endif::azure[]

ifdef::aws[]

* link:set-up-amazon-web-services.html["Amazon Web Servicesをセットアップする"^]


endif::aws[]

ifdef::gcp[]

* link:set-up-google-cloud.html["Google Cloud をセットアップします"^]


endif::gcp[]



== Astra Control Serviceに自己管理型プライベートクラスタを追加

プライベートクラスタをAstra Control Serviceに追加できるようになりました。

.作業を開始する前に
[%collapsible%open]
====
自己管理型クラスタは、ユーザが直接プロビジョニングおよび管理するクラスタです。Astra Control Serviceは、パブリッククラウド環境で実行される自己管理型クラスタをサポートします。自己管理型クラスタでは、Astra Tridentを使用してネットアップストレージサービスを操作したり、Container Storage Interface（CSI）ドライバを使用してAmazon Elastic Block Store（EBS）、Azure Managed Disks、Google Persistent Diskを操作したりできます。

Astra Control Serviceは、次のKubernetesディストリビューションを使用する自己管理クラスタをサポートします。

* Red Hat OpenShift Container Platform
* Rancher Kubernetes Engineの略
* アップストリームKubernetes


自己管理型クラスタは、次の要件を満たしている必要があります。

* クラスタにインターネット経由でアクセスできる必要があります。
* クラスタをオンプレミスネットワーク内でホストすることはできません。パブリッククラウド環境でホストする必要があります。
* CSIドライバで有効にしたストレージを使用または使用する予定の場合は、適切なCSIドライバをクラスタにインストールする必要があります。CSIドライバを使用してストレージを統合する方法の詳細については、ご使用のストレージサービスのマニュアルを参照してください。
* context要素を1つだけ含むcluster kubeconfigファイルにアクセスできる必要があります。をクリックします link:create-kubeconfig.html["以下の手順を参照して"^] kubeconfigファイルを生成します。
* *rancherのみ*: Rancher環境でアプリケーションクラスタを管理する場合、rancherから提供されたkubeconfigファイルでアプリケーションクラスタのデフォルトコンテキストを変更して、rancher APIサーバコンテキストではなくコントロールプレーンコンテキストを使用します。これにより、 Rancher API サーバの負荷が軽減され、パフォーマンスが向上します。
* * Astra Trident *：NetAppストレージを使用している、または使用を予定している場合は、最新バージョンのAstra Tridentがインストールされていることを確認します。Astra Tridentがすでにインストールされている場合は、 link:check-astra-trident-version.html["最新バージョンであることを確認します"^]。
+

NOTE: 可能です https://docs.netapp.com/us-en/trident/trident-get-started/kubernetes-deploy.html#choose-the-deployment-method["Astra Tridentを導入"^] Tridentオペレータ（手動またはHelmチャートを使用）またはを使用します `tridentctl`。Astra Tridentのインストールまたはアップグレードを行う前に、を参照してください https://docs.netapp.com/us-en/trident/trident-get-started/requirements.html["サポートされるフロントエンド、バックエンド、およびホスト構成"^]。

+
** * Astra Tridentストレージバックエンドの設定*：Astra Tridentストレージバックエンドが少なくとも1つ必要です https://docs.netapp.com/us-en/trident/trident-get-started/kubernetes-postdeployment.html#step-1-create-a-backend["を設定します"^] クラスタのポリシーを確認してください。
** * Astra Tridentストレージクラスを設定*：Astra Tridentストレージクラスを少なくとも1つ設定する必要があります https://docs.netapp.com/us-en/trident/trident-use/manage-stor-class.html["を設定します"^] クラスタのポリシーを確認してください。デフォルトのストレージクラスが設定されている場合は、1つのストレージクラスだけにそのアノテーションを設定します。
** * Astra Tridentボリュームスナップショットコントローラとボリュームスナップショットクラスがインストールおよび設定されている*：ボリュームスナップショットコントローラがである必要があります https://docs.netapp.com/us-en/trident/trident-use/vol-snapshots.html#deploying-a-volume-snapshot-controller["インストール済み"^] Astra Controlでスナップショットを作成できるようにします。Astra Tridentが少なくとも1つ `VolumeSnapshotClass` はい https://docs.netapp.com/us-en/trident/trident-use/vol-snapshots.html#step-1-set-up-a-volumesnapshotclass["セットアップ"^] 管理者による。




====
.手順
. ダッシュボードで、 * Kubernetes クラスタの管理 * を選択します。
+
プロンプトに従ってクラスタを追加します。

. *プロバイダ*：*[その他]*タブを選択して、自己管理クラスタに関する詳細を追加します。
. *その他*：をアップロードして、自己管理クラスタに関する詳細を指定します `kubeconfig.yaml` ファイルまたはの内容を貼り付けます `kubeconfig.yaml` クリップボードからファイル。
+

NOTE: 自分で作成する場合は `kubeconfig` ファイルには、* 1つの*コンテキストエレメントのみを定義する必要があります。を参照してください https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/["Kubernetes のドキュメント"^] を参照してください `kubeconfig` ファイル。

. *クレデンシャル名*：Astra Controlにアップロードする自己管理型クラスタのクレデンシャルの名前を指定します。デフォルトでは、クレデンシャル名がクラスタの名前として自動的に入力されます。
. *プライベートルート識別子*：Astra Connectorから取得できるプライベートルート識別子を入力します。を使用してAstra Connectorを照会した場合 `kubectl get` プライベートルート識別子はと呼ばれます `ASTRACONNECTORID`。
+

NOTE: プライベートルート識別子は、AstraでプライベートKubernetesクラスタを管理できるようにするAstra Connectorに関連付けられた名前です。この場合、プライベートクラスタは、APIサーバをインターネットに公開しないKubernetesクラスタです。

. 「 * 次へ * 」を選択します。
. （オプション）* Storage *：必要に応じて、このクラスタに導入されたKubernetesアプリケーションでデフォルトで使用するストレージクラスを選択します。
+
.. クラスタの新しいデフォルトのストレージクラスを選択するには、*[新しいデフォルトのストレージクラスを割り当てる]*チェックボックスを有効にします。
.. 新しいデフォルトのストレージクラスをリストから選択します。
+
[NOTE]
====
各クラウドプロバイダのストレージサービスには、コスト、パフォーマンス、耐障害性に関する次の情報が表示されます。

ifdef::gcp[]

*** Cloud Volumes Service for Google Cloud：価格、パフォーマンス、耐障害性に関する情報
*** Google Persistent Disk：コスト、パフォーマンス、耐障害性に関する情報は提供されません


endif::gcp[]

ifdef::azure[]

*** Azure NetApp Files ：パフォーマンスと耐障害性に関する情報
*** Azure Managed Disks：価格、パフォーマンス、耐障害性に関する情報は提供されません


endif::azure[]

ifdef::aws[]

*** Amazon Elastic Block Store：価格、パフォーマンス、耐障害性に関する情報がない
*** Amazon FSX for NetApp ONTAP ：価格、パフォーマンス、耐障害性に関する情報は提供されません


endif::aws[]

*** NetApp Cloud Volumes ONTAP ：価格、パフォーマンス、耐障害性に関する情報は提供されません


====
+
ストレージクラスごとに、次のいずれかのサービスを利用できます。





ifdef::gcp[]

* https://cloud.netapp.com/cloud-volumes-service-for-gcp["Cloud Volumes Service for Google Cloud"^]
* https://cloud.google.com/persistent-disk/["Google Persistent Disk のことです"^]


endif::gcp[]

ifdef::azure[]

* https://cloud.netapp.com/azure-netapp-files["Azure NetApp Files の特長"^]
* https://docs.microsoft.com/en-us/azure/virtual-machines/managed-disks-overview["Azure で管理されるディスク"^]


endif::azure[]

ifdef::aws[]

* https://docs.aws.amazon.com/ebs/["Amazon Elastic Block Store"^]
* https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/what-is-fsx-ontap.html["NetApp ONTAP 対応の Amazon FSX"^]


endif::aws[]

* https://www.netapp.com/cloud-services/cloud-volumes-ontap/what-is-cloud-volumes/["NetApp Cloud Volumes ONTAP の略"^]
+
の詳細を確認してください link:../learn/aws-storage.html["Amazon Web Servicesクラスタのストレージクラス"]。の詳細を確認してください link:../learn/azure-storage.html["AKS クラスタのストレージクラス"]。の詳細を確認してください link:../learn/choose-class-and-size.html["GKE クラスタのストレージクラス"]。

+
.. 「 * 次へ * 」を選択します。
.. *確認と承認*：構成の詳細を確認します。
.. [Add]*を選択して、Astra Control Serviceにクラスタを追加します。






== デフォルトのストレージクラスを変更する

クラスタのデフォルトのストレージクラスは変更できます。



=== Astra Controlを使用してデフォルトのストレージクラスを変更する

クラスタのデフォルトのストレージクラスは、Astra Control内から変更できます。以前にインストールしたストレージバックエンドサービスをクラスタで使用している場合は、このメソッドを使用してデフォルトのストレージクラスを変更できない可能性があります（*デフォルトに設定*アクションは選択できません）。この場合は、を実行できます <<コマンドラインを使用してデフォルトのストレージクラスを変更します>>。

.手順
. Astra Control Service UI で、 [* Clusters] を選択します。
. [* Clusters]ページで、変更するクラスタを選択します。
. [ * ストレージ * ] タブを選択します。
. 「*ストレージクラス*」カテゴリを選択します。
. デフォルトとして設定するストレージクラスの* Actions *メニューを選択します。
. 「*デフォルトに設定*」を選択します。




=== コマンドラインを使用してデフォルトのストレージクラスを変更します

Kubernetesコマンドを使用してクラスタのデフォルトのストレージクラスを変更することができます。この方法は、クラスタの構成に関係なく機能します。

.手順
. Kubernetesクラスタにログインします。
. クラスタ内のストレージクラスを表示します。
+
[source, console]
----
kubectl get storageclass
----
. デフォルトのストレージクラスからデフォルトの指定を削除する。<SC_NAME> をストレージクラスの名前に置き換えます。
+
[source, console]
----
kubectl patch storageclass <SC_NAME> -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"false"}}}'
----
. 別のストレージクラスをデフォルトとしてマークします。<SC_NAME> をストレージクラスの名前に置き換えます。
+
[source, console]
----
kubectl patch storageclass <SC_NAME> -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'
----
. 新しいデフォルトストレージクラスを確認します。
+
[source, console]
----
kubectl get storageclass
----


ifdef::azure[]
